//g++  5.4.0
 
#include<bits/stdc++.h>
using namespace std;
 
#define ff first
#define ss second
#define int long long
#define pb push_back
#define pii pair< int,int >
#define fast ios::sync_with_stdio(0) , cin.tie(0) , cout.tie(0) ;
#define L(p) 2*p+1
#define R(p) 2*p+2
 
const int nax = 2e5+10;
int jt[4*nax];
pii lz[4*nax];
 
int fun(int a,int b)
{
    return a+b; // whatever u wish
}
void build(int l , int h , int p )
{
	if(l == h)
	{
		cin >> jt[p];
		return;
	}
	int m = (l+h)>>1;
	build(l , m , L(p));
	build(m+1 , h , R(p));
	jt[p] = fun(jt[L(p)],jt[R(p)]);
	return;
}
int nth_term(pii p,int n)
{
    int a = p.ff;
    int d = p.ss-p.ff;
    return a + (n-1)*d;
}
void push(int l,int h,int p )
{
    if( l!=h )
    {
        lz[L(p)].ff += lz[p].ff;
        lz[L(p)].ss += lz[p].ss;
        int m = (l+h)>>1;
        lz[R(p)].ff += nth_term(lz[p] , m+2-l);
        lz[R(p)].ss += nth_term(lz[p] , m+3-l);
    }
    
    int last_term = nth_term(lz[p] , h-l+1);
    jt[p] += ((h-l+1) * ( lz[p].ff + last_term ) )/2;
    lz[p].ff = lz[p].ss = 0;
    return ;
}
void update(int l ,int h , int p, int ql, int qh,int v)
{
    if( lz[p].ff ) push( l,h,p );
	if(l > qh || h < ql)
		return;
	else if(l >= ql && h <= qh)
	{
		lz[p].ff += v;
        lz[p].ss += (v+1);
        push( l,h,p );
		return;
	}
	int m = (l + h )>> 1;
	update( l , m , L(p) ,ql ,qh,v);
	update(m+1, h , R(p) , ql ,qh,v+max(0LL,m-max(l,ql)+1));
    jt[p] = fun(jt[L(p)] , jt[R(p)] );
	return;
}
 
int query(int l,int h, int p, int ql ,int qh)
{
    if( lz[p].ff ) push( l,h,p );
	if(l > qh || h < ql)
		return 0;
	else if(l >= ql && h <= qh)
		return jt[p] ;
	int m = (l + h )>> 1;
	int p1 = query( l , m , L(p) ,ql ,qh);
	int p2 = query(m+1 , h , R(p) , ql ,qh);
	return fun(p1,p2);
}
signed main()
{
    fast;
    int n , q;
    cin >> n >> q;
    build( 1,n,0 );
    while( q-- )
    {
        int t,a,b;
        cin >> t >> a >> b;
        if( t == 1 )
            update( 1,n,0,a,b,1 );
        else
            cout << query(1,n,0,a,b) << "\n";
    }
}
